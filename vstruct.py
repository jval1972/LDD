# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------

import ply.lex as lex
import ply.yacc as yacc
import random

# vstruct tokens
#
tokens = ('NUMBER',
          'LPAR',
          'RPAR',
          'OP_EQ',
          'OP_NOTEQ',
          'OP_GT',
          'OP_LT',
          'OP_GTEQ',
          'OP_LTEQ',
          'OP_IS',
          'OP_ISNOT',
          'OP_AND',
          'OP_OR',
          'KW_IF',
          'KW_ELSE',
          'KW_CONNECTED',
          'KW_CONNECT',
          'KW_IGNORE',
          'KW_COPY',
          'KW_SET',
          'PARAM',
          'STRING',
          )

# regex for simple tokens
#
# Regular expression rules for simple tokens
t_LPAR = r'\('
t_RPAR = r'\)'
t_OP_EQ = r'=='
t_OP_NOTEQ = r'!='
t_OP_GT = r'>'
t_OP_LT = r'<'
t_OP_GTEQ = r'>='
t_OP_LTEQ = r'<='
t_OP_ISNOT = r'is\wnot'
t_KW_ELSE = r'else'
t_KW_CONNECTED = r'connected'
t_KW_CONNECT = r'connect'
t_KW_IGNORE = r'ignore'
t_KW_COPY = r'copy'
t_STRING = r'"\w+"'
t_PARAM = r'\w+'


# regex rule with action code
#
def t_NUMBER(t):
    r'\d+[0-9\.]*'
    t.value = float(t.value)
    return t


def t_OP_IS(t):
    r'is'
    return t


def t_OP_OR(t):
    r'or'
    return t


def t_OP_AND(t):
    r'and'
    return t


def t_KW_IF(t):
    r'if'
    return t


def t_KW_SET(t):
    r'set'
    return t


# track line numbers
#
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)


# ignored characters (spaces and tabs)
t_ignore = ' \t'


# Error handling rule
def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

# Build the lexer
LEXER = lex.lex()
LEXER_STACK = []

def test_lex():
    print 'test_lex'
    r = ["connect if underMaterial_singlescatterK > 0 " +
         "or (enableSinglescatter == 1 and (singlescatterK > 0" +
         "or singlescatterK is connected or singlescatterDirectGain > 0 " +
         "or singlescatterDirectGain is connected)) ",
         "connect if ((rrReflectionK is connected or rrReflectionK > 0) " +
         "and enableRR == 1) or underMaterial_walterReflectionK is connected" +
         " else set 0",
         "connect if enableClearcoat == 1 "]
    for s in r:
        print '-' * 80
        print s
        LEXER.input(s)
        while True:
            tok = LEXER.token()
            if not tok:
                break      # No more input
            print(tok)


# This is the BNF extracted from VirtualStructConditionalGrammar.yy
#
#
# %start statement
# %token <string> NUMBER
# %token <string> STRING
# %token <string> PARAM
# %token LPAR RPAR
# %token OP_EQ OP_NOTEQ
# %token OP_GT OP_LT OP_GTEQ OP_LTEQ
# %token OP_IS OP_ISNOT
# %token OP_AND OP_OR
# %token KW_IF KW_ELSE KW_CONNECTED KW_CONNECT KW_IGNORE KW_COPY KW_SET
# %token UNRECOGNIZED_TOKEN
#
# %left OP_OR
# %left OP_AND
#
# %%
#
# value : STRING
#       | NUMBER
#
# op : OP_EQ
#    | OP_NOTEQ
#    | OP_GT
#    | OP_LT
#    | OP_GTEQ
#    | OP_LTEQ
#
# expr: PARAM op value
#     | OP_AND op value
#     | OP_OR op value
#     | OP_IS op value
#     | KW_IF op value
#     | KW_ELSE op value
#     | KW_CONNECTED op value
#     | KW_CONNECT op value
#     | KW_IGNORE op value
#     | KW_COPY op value
#     | KW_SET op value
#     | PARAM OP_IS KW_CONNECTED
#     | PARAM OP_ISNOT KW_CONNECTED
#     | PARAM OP_IS KW_SET
#     | PARAM OP_ISNOT KW_SET
#     | LPAR expr RPAR
#     | expr OP_AND expr
#     | expr OP_OR expr
#
# action : KW_COPY PARAM
#        | KW_CONNECT
#        | KW_IGNORE
#        | KW_SET STRING
#        | KW_SET NUMBER
#
# statement : action KW_IF expr KW_ELSE action
#           | action KW_IF expr
#           | KW_IF expr KW_ELSE action
#           | action
#           | expr
#

start = 'statement'


def p_value_string(p):
    'value : STRING'
    p[0] = p[1]


def p_value_number(p):
    'value : NUMBER'
    p[0] = p[1]


# op --------------------------------------------------------------------------


def p_op_eq(p):
    'op : OP_EQ'
    p[0] = '=='


def p_op_noteq(p):
    'op : OP_NOTEQ'
    p[0] = '!='


def p_op_gt(p):
    'op : OP_GT'
    p[0] = '>'


def p_op_lt(p):
    'op : OP_LT'
    p[0] = '<'


def p_op_gteq(p):
    'op : OP_GTEQ'
    p[0] = '>='


def p_op_lteq(p):
    'op : OP_LTEQ'
    p[0] = '<='


# expr ------------------------------------------------------------------------


def p_expr_param_op_value(p):
    'expr : PARAM op value'
    # debug(p_expr_param_op_value.__doc__, p)
    pval = CC.paramGetValue(p[1])
    p[0] = eval('%s %s %s' % (pval, p[2], p[3]))
    debug(p_expr_param_op_value.__doc__, p, '%s = %s' % (p[1], str(pval)))


def p_expr_and_op_value(p):
    'expr : OP_AND op value'
    # PARAM named 'and', special case
    # debug(p_expr_and_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_and_op_value.__doc__, p)


def p_expr_or_op_value(p):
    'expr : OP_OR op value'
    # PARAM named 'or', special case
    # debug(p_expr_or_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_or_op_value.__doc__, p)


def p_expr_is_op_value(p):
    'expr : OP_IS op value'
    # PARAM named 'is', special case
    # debug(p_expr_is_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_is_op_value.__doc__, p)


def p_expr_if_op_value(p):
    'expr : KW_IF op value'
    # PARAM named 'if', special case
    # debug(p_expr_if_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_if_op_value.__doc__, p)


def p_expr_else_op_value(p):
    'expr : KW_ELSE op value'
    # PARAM named 'else', special case
    # debug(p_expr_else_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_else_op_value.__doc__, p)


def p_expr_connected_op_value(p):
    'expr : KW_CONNECTED op value'
    # PARAM named 'connected', special case
    # debug(p_expr_connected_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_connected_op_value.__doc__, p)


def p_expr_connect_op_value(p):
    'expr : KW_CONNECT op value'
    # PARAM named 'connect', special case
    # debug(p_expr_connect_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_connect_op_value.__doc__, p)


def p_expr_ignore_op_value(p):
    'expr : KW_IGNORE op value'
    # PARAM named 'ignore', special case
    # debug(p_expr_ignore_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_ignore_op_value.__doc__, p)


def p_expr_copy_op_value(p):
    'expr : KW_COPY op value'
    # PARAM named 'copy', special case
    # debug(p_expr_copy_op_value.__doc__, p)
    p_expr_param_op_value(p)
    debug(p_expr_copy_op_value.__doc__, p)


# def p_expr_set_op_value(p):
#     'expr : KW_SET op value'
#     # PARAM named 'set', special case
#     debug(p_expr_set_op_value.__doc__, p)
#     p_expr_param_op_value(p)
#     debug(p_expr_set_op_value.__doc__, p)


def p_expr_param_is_connected(p):
    'expr : PARAM OP_IS KW_CONNECTED'
    # debug(p_expr_param_is_connected.__doc__, p)
    p[0] = CC.paramIsConnected(p[1])
    debug(p_expr_param_is_connected.__doc__, p)


def p_expr_param_isnot_connected(p):
    'expr : PARAM OP_ISNOT KW_CONNECTED'
    # debug(p_expr_param_isnot_connected.__doc__, p)
    p[0] = not CC.paramIsConnected(p[1])
    debug(p_expr_param_isnot_connected.__doc__, p)


# def p_expr_param_is_set(p):
#     'expr : PARAM OP_IS KW_SET'
#     # diffuseColor is set ? IGNORED
#     debug(p_expr_param_is_set.__doc__, p)


# def p_expr_param_isnot_set(p):
#     'expr : PARAM OP_ISNOT KW_SET'
#     # diffuseColor is not set ? IGNORED
#     debug(p_expr_param_isnot_set.__doc__, p)


def p_expr_lpar_expr_rpar(p):
    'expr : LPAR expr RPAR'
    p[0] = p[2]
    debug(p_expr_lpar_expr_rpar.__doc__, p)


def p_expr_expr_and_expr(p):
    'expr : expr OP_AND expr'
    p[0] = eval('%s and %s' % (p[1], p[3]))
    debug(p_expr_expr_and_expr.__doc__, p)


def p_expr_expr_or_expr(p):
    'expr : expr OP_OR expr'
    p[0] = eval('%s or %s' % (p[1], p[3]))
    debug(p_expr_expr_or_expr.__doc__, p)


# action ----------------------------------------------------------------------


def p_action_copy_param(p):
    'action : KW_COPY PARAM'
    CC.actionSet('copyParam', p[2])
    CC.valueSet(p[2])
    p[0] = 'copyParam'
    debug(p_action_copy_param.__doc__, p)


def p_action_connect(p):
    'action : KW_CONNECT'
    CC.actionSet('connect')
    p[0] = 'connect'
    debug(p_action_connect.__doc__, p)


def p_action_ignore(p):
    'action : KW_IGNORE'
    CC.actionSet('ignore')
    p[0] = 'ignore'
    debug(p_action_ignore.__doc__, p)


def p_action_set_string(p):
    'action : KW_SET STRING'
    CC.actionSet('setString')
    CC.valueSet(p[2])
    p[0] = 'setString'
    debug(p_action_set_string.__doc__, p)


def p_action_set_number(p):
    'action : KW_SET NUMBER'
    CC.actionSet('setNumber')
    CC.valueSet(p[2])
    p[0] = 'setNumber'
    debug(p_action_set_number.__doc__, p)


# statement -------------------------------------------------------------------


def p_statement_action_if_expr_else_action(p):
    'statement : action KW_IF expr KW_ELSE action'
    if p[3]:
        CC.actionChoose('action')
    else:
        CC.actionChoose('fallback')
    p[0] = p[3]
    debug(p_statement_action_if_expr_else_action.__doc__, p)


def p_statement_action_if_expr(p):
    'statement : action KW_IF expr'
    if not p[3]:
        CC.actionSet(None)
    p[0] = p[3]
    debug(p_statement_action_if_expr.__doc__, p)


def p_statement_if_expr_else_action(p):
    'statement : KW_IF expr KW_ELSE action'
    if p[2]:
        CC.actionChoose('action')
    else:
        CC.actionChoose('fallback')
    p[0] = p[2]
    debug(p_statement_if_expr_else_action.__doc__, p)


def p_statement_action(p):
    'statement : action'
    CC.actionSet(p[1])
    p[0] = p[1]
    debug(p_statement_action.__doc__, p)


def p_statement_expr(p):
    'statement : expr'
    p[0] = p[1]
    debug(p_statement_expr.__doc__, p)


precedence = (
    ('left', 'OP_OR'),
    ('left', 'OP_AND'),
)


# Error rule for syntax errors
#
def p_error(p):
    print("Syntax error in input! > '%s'" % p)

# Build the parser
#
PARSER = yacc.yacc(write_tables=False)

# test
#
def test_yacc():
    print 'test_yacc'
    r = ["connect if underMaterial_singlescatterK > 0 " +
         "or (enableSinglescatter == 1 and (singlescatterK > 0 " +
         "or singlescatterK is connected or singlescatterDirectGain > 0 " +
         "or singlescatterDirectGain is connected)) ",
         "connect if ((rrReflectionK is connected or rrReflectionK > 0) " +
         "and enableRR == 1) or " +
         "underMaterial_walterReflectionK is connected " +
         "else set 0",
         "connect if enableClearcoat == 1 "]
    cobj = defaultClient()
    for s in r:
        print '-' * 80
        print s
        evalExpr(s, cobj)
        print getLastTrace()


class defaultClient:

    def __init__(self):
        self.action = None
        self.actionValue = None
        self.fallback = None
        self.fallbackValue = None

    def paramGetValue(self, param):
        # random decision for testing
        return random.random()

    def paramIsConnected(self, param):
        # random decision for testing
        return True if random.random() > 0.5 else False

    def actionSet(self, action):
        if self.action is None:
            self.action = action
        else:
            self.fallback = action
        logTrace('Client actionSet :'.rjust(45) +
                 ' action = %s  fallback = %s'
                 % (self.action, self.fallback))

    def actionChoose(self, which):
        if which == 'action':
            self.fallback = None
        else:
            self.action = None

    def actionGet(self):
        if self.action is not None:
            return self.action
        else:
            return self.fallback

    def valueSet(self, value):
        if self.action is not None and self.actionValue is None:
            self.actionValue = value
        else:
            self.fallbackValue = value
        logTrace('Client valueSet :'.rjust(45) +
                 ' actionValue = %s  fallbackValue = %s'
                 % (self.actionValue, self.fallbackValue))

    def valueGet(self):
        if self.action is not None:
            return self.actionValue
        else:
            return self.fallbackValue

CLIENT_STACK = []
LASTTRACE_STACK = []
CC = defaultClient()


def evalExpr(expr, clientObj):
    global CC
    global CLIENT_STACK
    global LASTTRACE
    global LASTTRACE_STACK
    global PARSER
    global LEXER
    global LEXER_STACK
    traceInit(expr)
    CLIENT_STACK.append(CC)
    LASTTRACE_STACK.append(LASTTRACE)
    CC = clientObj
    LEXER_STACK.append(LEXER)
    LEXER = lex.lex()
    result = PARSER.parse(expr, lexer=LEXER)
    CC = CLIENT_STACK[-1]
    LEXER = LEXER_STACK[-1]
    LASTTRACE = LASTTRACE_STACK[-1]
    CLIENT_STACK.pop()
    LASTTRACE_STACK.pop()
    LEXER_STACK.pop()
    return result


def debug(msg, array, msg2=None):
    global LASTTRACE
    s = ''
    for i in range(len(array)):
        s += ' ' + repr(array[i])
    w = 45
    if msg2 is None:
        LASTTRACE += '%s  ->  %s\n' % (msg.rjust(w), s)
    else:
        LASTTRACE += '%s  ->  %s  ( %s )\n' % (msg.rjust(w), s, msg2)


def traceInit(expr):
    global LASTTRACE
    LASTTRACE = '-' * 80 + '\n'
    LASTTRACE += 'Expr: "%s"\n' % expr
    LASTTRACE += '-' * 80 + '\n'


def logTrace(msg):
    global LASTTRACE
    LASTTRACE += msg + '\n'


def getLastTrace():
    global LASTTRACE
    return LASTTRACE
